# 学びの記録

## 技術的知見

- Agent SDK `query()` はClaude Codeサブプロセスをspawnする。`Skill`ツールを許可するとネストしたプロセスが起動し、API 400 (tool use concurrency) エラーになる。スキル内容はシステムプロンプトに埋め込み、直接ツール（WebSearch等）で実行させる
- LLMの最終応答（`done`イベント）はプロンプトでJSON出力を指定しても、Markdown要約を返すことがある。パースソースを多段にする（LLM応答 → ツール結果 → ファイル出力）か、構造化出力を強制する仕組みが必要

## 解決済みトラブル

- TypeScript の `interface` は `extends Record<string, unknown>` のジェネリクス制約を満たせない（index signature が暗黙付与されない）。ドメイン型を interface で定義する場合、制約を緩めるか `type` を使う

## ベストプラクティス

- テンプレートメソッドパターンで基底の `execute()` を override してラッパーにする場合、ライフサイクルフック等のミュータブルな状態を差し替えたら `finally` で必ず復元する（次回呼び出しで状態がリークする）
- ワークフロー内で自動的にキュー/ストアに追加する処理と、UI側の手動追加ボタンが共存すると重複する。副作用（キュー追加・通知等）の責務は一箇所に集約する
- スキルがtempファイルに結果を書く場合、ワークフロー開始時にクリアしないと前回の結果を誤って拾う
- LLMエージェントのワークフロー共通化は、規模が小さいうちは「ライフサイクル（start/complete/fail/retry）の共通化」から始める。宣言的定義（LangGraph等）は有効なアプローチだが、エージェント2-3個の段階ではエンジン設計・保守コストが再利用メリットを上回る

## 再利用可能な知恵

- マルチプラットフォーム（Discord/Slack/Web UI等）の役割分担は「入力/出力」ではなく「能動/受動」で分ける。ユーザー起点の操作（指示→結果→判断）は1つのプラットフォームで完結させ、システム起点の通知（アラート・レポート等）は別で受け取る設計にするとコンテキストスイッチが最小化される
